substitutions:
  name: pool
  upper_name: "Swimming pool"
  low_level_sensor_pin: "36"
  high_level_sensor_pin: "35"
  pump_running_sensor_pin: "39"
  pool_lights_physical_switch_pin: "34"
  pump_relay_pin: "33"
  pool_lights_relay_pin: "32"
  pump_manual_physical_switch_pin: "16"
  pump_automation_physical_switch_pin: "13"
  rain_sensor_pin: "3"
  #### Do not use pin 14, as it caused some errors restarting the device when pulled down

packages:
  device_base: !include common/device_base.pool.yaml
  ethernet: !include common/olimex-esp32-poe.config.yaml
  basic_control: !include common/basic_control.yaml
  sun: !include common/sun.yaml

esphome:
  name: pool
  includes:
    - time_control.hpp
    - pool.hpp
  on_boot: 
    priority: 800.0
    then:
      - delay: 20s
      - lambda: |-
          // If this variable has been deleted for any reason, reset it
          if (id(last_automatic_pump) == 0) {
            id(last_automatic_pump) = (id(time_sntp).now().timestamp - (3600 * 24 * 3));
            id(secure_pumping) = id(pool_low_level).state;
          }
          id(last_automatic_pump_ha).publish_state(get_time_formated(to_string(id(last_automatic_pump))));
          set_new_pumping_time();
          id(filling_available) = water_available();
          if(id(pump_next_on).state != "Sin programaciones" && id(pump_next_off).state != "Sin programaciones" &&
          id(pump_next_on).state > id(pump_next_off).state && id(secure_pumping) && !id(filling_rn) && id(pump_automation_bool))
            id(swimming_pool_pump).turn_on();

# Enable Home Assistant API
api:
  services:
    - service: filling_start
      then:
        - switch.turn_off: swimming_pool_pump
        - delay: 2s
        - lambda: id(filling_rn) = true;
        - homeassistant.service: # Opens the valve
            service: esphome.irrigation_filling_start
        - script.execute: pool_filling_request_loop
    - service: manual_filling_start
      then:
        - switch.turn_off: swimming_pool_pump
        - delay: 2s
        - lambda: id(filling_rn) = true;
        - homeassistant.service:
            service: esphome.irrigation_filling_start
    - service: filling_completed
      then:
        - lambda: |-
            id(filling_rn) = false;
            id(pool_filling_requested) = false;
            if (id(pump_next_on).state != "Sin programaciones" && id(pump_next_off).state != "Sin programaciones" &&
            id(pump_next_on).state > id(pump_next_off).state && id(secure_pumping))
              id(swimming_pool_pump).turn_on();
    - service: filling_requested
      then:
        - lambda: |-
            id(pool_filling_requested) = true;

# ============================================================================ #
globals: 
  ## Bool to save switch states
  - id: pump_automation_bool
    type: bool
    restore_value: yes
  - id: pump_automation_full_bool
    type: bool
    restore_value: yes
  - id: pump_manual_bool
    type: bool
    restore_value: yes
  - id: pump_winter_mode_bool
    type: bool
    restore_value: yes

  #### Bool to save filling state
  - id: pool_filling_bool
    type: bool
    restore_value: yes
  - id: pool_filling_requested
    type: bool
    restore_value: yes
  - id: filling_rn
    type: bool
    restore_value: yes
  - id: secure_pumping
    type: bool
    restore_value: yes

  #### Bool to check if water available
  - id: filling_available
    type: bool
    restore_value: yes

  #### Last automatic pumping
  - id: last_automatic_pump
    type: long long int
    restore_value: yes

  #### Weather metrics
  - id: mean_temp
    type: float
    restore_value: yes

# ============================================================================ #
script:
  - id: pool_filling_request_loop
    then:
      - while:
          condition:
            and:
              - binary_sensor.is_off: pool_high_level
              - lambda: return id(filling_available);
          then:
          - homeassistant.service: 
              service: esphome.irrigation_request_more_pool_water
          - delay: 60s
  - id: pool_filling_request_today
    then:
      - homeassistant.service:
          service: esphome.irrigation_request_pool_water

# ============================================================================ #
binary_sensor:
  #### Pool level sensors
  - platform: gpio
    pin:
      number: ${low_level_sensor_pin}
      inverted: true
      mode:
        input: true
    name: "Low level pool sensor"
    id: pool_low_level
    device_class: moisture
    publish_initial_state: True
    filters:
      delayed_on_off: 700ms
    on_state: 
      then:
        - lambda: |-
            if(!id(pool_low_level).state) {
              id(secure_pumping) = false;
              if(id(pump_automation_bool))
                id(swimming_pool_pump).turn_off();
            }

  - platform: gpio
    pin:
      number: ${high_level_sensor_pin}
      inverted: true
      mode:
        input: true
    name: "High level pool sensor"
    id: pool_high_level
    device_class: moisture
    publish_initial_state: True
    filters:
      delayed_on_off: 700ms
    on_state: 
      then:
        - lambda: |-
            if (id(pool_filling_bool) && !id(pool_high_level).state && !id(pool_filling_requested)) {
              id(pool_filling_request_today).execute();
            }
            else if (id(pool_high_level).state) id(secure_pumping) = true;

  - platform: gpio
    pin:
      number: ${pump_running_sensor_pin}
      mode:
        input: true
    name: Pool pump running
    id: pool_pump_running_sensor
    icon: mdi:pump
    device_class: running
    publish_initial_state: True
    filters:
      delayed_on_off: 50ms

  - platform: gpio
    pin:
      number: ${pool_lights_physical_switch_pin}
      mode:
        input: true
    name: Pool lights switch (debug)
    id: pool_lights_physical_switch
    publish_initial_state: True
    filters:
      delayed_on_off: 50ms
    on_state: 
      then:
        - lambda: |-
            if (id(pool_lights_physical_switch).state) id(pool_lights).turn_on().perform();
            else if (!id(pool_lights_physical_switch).state) id(pool_lights).turn_off().perform();

  - platform: gpio
    pin: 
      number: ${pump_manual_physical_switch_pin}
      mode:
        input: True
        pulldown: True
    name: Pool pump manual switch (debug)
    id: pump_manual_physical_switch
    publish_initial_state: True
    filters:
      delayed_on_off: 70ms
    on_state: 
      then:
        - lambda: |-
            if (id(pump_manual_physical_switch).state) id(pump_manual).turn_on();
            else if (!id(pump_manual_physical_switch).state) id(pump_manual).turn_off();

  - platform: gpio
    pin: 
      number: ${pump_automation_physical_switch_pin}
      mode:
        input: True
        pulldown: True
    name: Pool pump automation switch (debug)
    id: pump_automation_physical_switch
    publish_initial_state: True
    filters:
      delayed_on_off: 40ms
    on_state: 
      then:
        - lambda: |-
            if (id(pump_automation_physical_switch).state) id(pump_automation).turn_on();
            else if (!id(pump_automation_physical_switch).state) {
              id(pump_manual).turn_off();
              id(pump_automation).turn_off();
            }

  #### For saving filling state
  - platform: homeassistant
    id: ui_pool_filling
    internal: True
    entity_id: switch.pool_filling_automation
    on_state:
      then:
        - lambda: |-
            id(pool_filling_bool) = id(ui_pool_filling).state;
            if (id(pool_filling_bool) && !id(pool_high_level).state && !id(pool_filling_requested)) {
              id(pool_filling_request_today).execute();
            }
            else if(!id(pool_filling_bool)) {
              id(pool_filling_requested) = false;
            }

# ============================================================================ #
sensor:
  #### Precipitation sensor
  #### Surface of the rain gauge: 5.2cm * 11.2cm = 58.24cm^2
  #### 7 flips per 11mL => 11/7 = 1.57mL per pulse
  #### 1mm rain = 5.824mL in the rain gauge (due to surface)
  #### pulses/mm = 5.824/(11/7) = 3.709554
  #### mm/pulse = 0.269574
  - platform: pulse_meter
    pin:
      number: ${rain_sensor_pin}
      mode:
        input: true
    name: "Rain flips"
    internal_filter_mode: PULSE
    internal_filter: 1ms
    internal: True
    total:
      unit_of_measurement: 'mm'
      name: 'Pluviometer'
      accuracy_decimals: 1
      filters:
        - multiply: 0.269574
  
  # ================================== #
  ## Home Assistant get sensors
  ### To retrieve weather metrics from home assistant
  - platform: homeassistant
    id: ui_mean_temp
    entity_id: sensor.exterior_temperature_mean_over_last_48_hours
    on_value: 
      then:
        - lambda: id(mean_temp) = id(ui_mean_temp).state;
  
  # ================================== #
  ## Countdown sensors
  - platform: template
    name: Pool pump left
    id: pump_left
    update_interval: 10s
    accuracy_decimals: 0
    unit_of_measurement: min
    icon: mdi:timer-outline
    lambda: |-
      if (id(swimming_pool_pump).state && (id(pump_automation_bool) || id(pump_winter_mode_bool))) {
        return ((atoi((id(pump_next_off).state).c_str()) - id(time_sntp).now().timestamp) / 60) + 1;
      }
      return 0;

  # ================================== #
  ## Next cycle duration
  - platform: template
    name: Pool pump next duration
    id: pool_pump_next_duration
    accuracy_decimals: 0
    unit_of_measurement: min
    icon: mdi:timer-outline
    lambda: |-
      if (id(pump_next_on).state == "Sin programaciones" || id(pump_next_off).state == "Sin programaciones") 
        return 0;
      if (atoi((id(pump_next_off).state).c_str()) > atoi((id(pump_next_on).state).c_str())) {
        return ((atoi((id(pump_next_off).state).c_str()) - atoi((id(pump_next_on).state).c_str())) / 60);
      }
      return id(pool_pump_next_duration).state;

# ============================================================================ #
switch:
  #### Pool pump relay switch
  - platform: gpio
    id: swimming_pool_pump
    internal: True
    pin:
      number: ${pump_relay_pin}
      inverted: True
    name: "Bomba de la piscina"
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - component.update: pump_left
    on_turn_off:
        - component.update: pump_left

  #### Switch for automation
  - platform: template
    name: Pool pump automation
    id: pump_automation
    lambda: return id(pump_automation_bool);
    turn_on_action:
      - lambda: |-
          id(pump_automation_bool) = true;
          id(pump_winter_mode_bool) = false;
          set_new_pumping_time();
      - delay: 100ms
      - lambda: |-
          if(id(pump_next_on).state != "Sin programaciones" && id(pump_next_off).state != "Sin programaciones" &&
            id(pump_next_on).state > id(pump_next_off).state && id(secure_pumping) && !id(filling_rn))
              id(swimming_pool_pump).turn_on();
          else id(swimming_pool_pump).turn_off();
    turn_off_action:
      - lambda: |-
          id(pump_automation_bool) = false;

  #### Switch for pump running full time, but still turning off with no water
  - platform: template
    name: Pool pump full time
    id: pump_automation_full
    lambda: return id(pump_automation_full_bool);
    turn_on_action:
      - lambda: |-
          id(pump_automation_full_bool) = true;
          set_new_pumping_time();
      - delay: 100ms
      - lambda: |-
          if(id(pump_next_on).state != "Sin programaciones" && id(pump_next_off).state != "Sin programaciones" &&
            id(pump_next_on).state > id(pump_next_off).state && id(secure_pumping) && !id(filling_rn))
              id(swimming_pool_pump).turn_on();
          else id(swimming_pool_pump).turn_off();
    turn_off_action:
      - lambda: |-
          id(pump_automation_full_bool) = false;
          set_new_pumping_time();
      - delay: 100ms
      - lambda: |-
          if(id(pump_next_on).state != "Sin programaciones" && id(pump_next_off).state != "Sin programaciones" &&
            id(pump_next_on).state > id(pump_next_off).state && id(secure_pumping) && !id(filling_rn))
              id(swimming_pool_pump).turn_on();
          else id(swimming_pool_pump).turn_off();

  #### Switch for manual use of the pump
  - platform: template
    name: Pool pump manual
    id: pump_manual
    lambda: return id(swimming_pool_pump).state;
    turn_on_action:
      - lambda: |-
          id(pump_automation_bool) = false;
          id(pump_winter_mode_bool) = false;
      - switch.turn_on: swimming_pool_pump
    turn_off_action:
      - switch.turn_off: swimming_pool_pump

  #### Winter mode switch
  - platform: template
    name: Winter mode
    id: pump_winter_mode
    icon: mdi:snowflake
    lambda: return id(pump_winter_mode_bool);
    turn_on_action:
      - lambda: |-
          id(pump_automation_bool) = false;
          id(pump_winter_mode_bool) = true;
          set_new_pumping_time();
      - delay: 100ms
      - lambda: |-
          if(id(pump_next_on).state != "Sin programaciones" && id(pump_next_off).state != "Sin programaciones" &&
            id(pump_next_on).state > id(pump_next_off).state)
              id(swimming_pool_pump).turn_on();
          else id(swimming_pool_pump).turn_off();
    turn_off_action:
      - lambda: |-
          id(pump_winter_mode_bool) = false;
          set_new_pumping_time();

  #### Switches for debugging
  - platform: template
    name: Secure pumping (debug)
    icon: mdi:security
    disabled_by_default: True
    lambda: return id(secure_pumping);
    turn_on_action:
      - lambda: id(secure_pumping) = true;
    turn_off_action:
      - lambda: id(secure_pumping) = false;
  - platform: template
    name: Filling right now (debug)
    icon: mdi:security
    disabled_by_default: True
    lambda: return id(filling_rn);
    turn_on_action:
      - lambda: id(filling_rn) = true;
    turn_off_action:
      - lambda: id(filling_rn) = false;

# ============================================================================ #
light:
  #### Pool lights
  - platform: binary
    name: "Luces de la piscina"
    id: pool_lights
    output: pool_lights_output
    icon: mdi:light-flood-down
    restore_mode: RESTORE_DEFAULT_OFF

output: 
  - id: pool_lights_output
    platform: gpio
    pin:
      number: ${pool_lights_relay_pin}
      inverted: True

# ============================================================================ #
text_sensor:
  #### Time
  - platform: template
    id: pool_time
    name: Pool time
    icon: mdi:calendar-clock

  # ================================== #
  ## Local variables for timestamps
  #### Pool pumping times
  - platform: template
    name: Pump timestamps on
    id: pump_timestamps_on
    update_interval: never
    internal: True
    on_value:
      then: 
        # Update the next scheduled run time
        - text_sensor.template.publish:
            id: pump_next_on
            state: !lambda |-
              return update_next_run(id(pump_timestamps_on).state);
        - text_sensor.template.publish:
            id: pump_next_on_ha
            state: !lambda |-
              return get_time_formated(id(pump_next_on).state);
  - platform: template
    name: Pump timestamps off
    id: pump_timestamps_off
    update_interval: never
    internal: True
    on_value:
      then: 
        # Update the next scheduled run time
        - text_sensor.template.publish:
            id: pump_next_off
            state: !lambda |-
              return update_next_run(id(pump_timestamps_off).state);
        - text_sensor.template.publish:
                id: pump_next_off_ha
                state: !lambda |-
                  return get_time_formated(id(pump_next_off).state);

  # ================================== #
  ## Local variables for next toogle
  - platform: template
    id: pump_next_on
    internal: True
  - platform: template
    name: Pool pump next on
    id: pump_next_on_ha
  - platform: template
    id: pump_next_off
    internal: True
    on_value:
      - then:
        - component.update: pool_pump_next_duration
  - platform: template
    name: Pool pump next off
    id: pump_next_off_ha

  #### Last automatic pumping
  - platform: template
    name: Last automatic pumping
    id: last_automatic_pump_ha

# ============================================================================ #
# Cron jobs
time:
  - platform: homeassistant
    id: time_sntp
    timezone: Europe/Madrid
    on_time:
      - seconds: 0
        minutes: 30
        hours: 0
        then:
          - lambda: set_new_pumping_time();
      - seconds: 0
        minutes: 0
        hours: 0,8,16
        then:
          - lambda: id(filling_available) = water_available();
      - seconds: 0
        minutes: /1
        then:
          - lambda: |-
              id(pool_time).publish_state(get_time_formated(to_string(id(time_sntp).now().timestamp)));

              if ((id(pump_winter_mode_bool) || (id(secure_pumping) && id(pump_automation_bool))) && !id(filling_rn) && scheduled_run(id(pump_next_on).state.c_str())) {
                id(swimming_pool_pump).turn_on();
                id(last_automatic_pump) = id(time_sntp).now().timestamp;
                id(last_automatic_pump_ha).publish_state(get_time_formated(to_string(id(last_automatic_pump))));
              }
              if ((id(pump_winter_mode_bool) || id(pump_automation_bool)) && scheduled_run(id(pump_next_off).state.c_str())) {
                id(swimming_pool_pump).turn_off();
                id(last_automatic_pump) = id(time_sntp).now().timestamp;
                id(last_automatic_pump_ha).publish_state(get_time_formated(to_string(id(last_automatic_pump))));
              }
              if (id(pool_filling_bool) && !id(pool_high_level).state && !id(pool_filling_requested)) {
                id(pool_filling_request_today).execute();
              }
              id(pump_timestamps_on).publish_state(update_list(id(pump_timestamps_on).state));
              id(pump_timestamps_off).publish_state(update_list(id(pump_timestamps_off).state));
